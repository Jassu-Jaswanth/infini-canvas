<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Canvas - Standalone Demo</title>
    <link rel="stylesheet" href="public/styles.css">
</head>
<body>
    <div id="app">
        <!-- Main Canvas -->
        <canvas id="drawingCanvas"></canvas>
        <canvas id="previewCanvas"></canvas>
        
        <!-- Tool Wheel -->
        <div id="toolWheel" class="tool-wheel">
            <button class="tool-btn" data-tool="pen" title="Pen">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                    <path d="M2 2l7.586 7.586"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="brush" title="Brush">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11l6-6"/>
                    <path d="M15 5l-3.5 3.5"/>
                    <path d="M20 10c0 6-8 12-14 12c-2 0-3.5-1.5-3.5-3.5c0-1.5 1-2.5 2.5-2.5c3 0 7-5 7-10c0-2.5-1.5-4-3-4"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="eraser" title="Eraser">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M20 20H9l-6-6 8-8 9 9-4 5z"/>
                    <line x1="18" y1="12" x2="12" y2="18"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="pan" title="Pan">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 9l7-7 7 7"/>
                    <path d="M5 15l7 7 7-7"/>
                    <path d="M9 5h6"/>
                    <path d="M9 19h6"/>
                </svg>
            </button>
        </div>
        
        <!-- Tool Options Panel -->
        <div id="toolOptions" class="tool-options">
            <div class="option-group">
                <label>Color</label>
                <input type="color" id="colorPicker" value="#000000">
                <div id="colorPresets" class="color-presets">
                    <button class="color-preset" style="background: #000000" data-color="#000000"></button>
                    <button class="color-preset" style="background: #FF0000" data-color="#FF0000"></button>
                    <button class="color-preset" style="background: #00FF00" data-color="#00FF00"></button>
                    <button class="color-preset" style="background: #0000FF" data-color="#0000FF"></button>
                    <button class="color-preset" style="background: #FFFF00" data-color="#FFFF00"></button>
                    <button class="color-preset" style="background: #FF00FF" data-color="#FF00FF"></button>
                    <button class="color-preset" style="background: #00FFFF" data-color="#00FFFF"></button>
                    <button class="color-preset" style="background: #808080" data-color="#808080"></button>
                </div>
            </div>
            
            <div class="option-group">
                <label>Size: <span id="sizeValue">5</span>px</label>
                <input type="range" id="brushSize" min="1" max="100" value="5">
            </div>
            
            <div class="option-group">
                <label>Opacity: <span id="opacityValue">100</span>%</label>
                <input type="range" id="brushOpacity" min="0" max="100" value="100">
            </div>
        </div>
        
        <!-- Controls -->
        <div id="controls" class="controls">
            <button id="saveBtn" class="control-btn">Save</button>
            <button id="loadBtn" class="control-btn">Load</button>
            <button id="clearBtn" class="control-btn">Clear</button>
            <button id="undoBtn" class="control-btn">Undo</button>
            <button id="redoBtn" class="control-btn">Redo</button>
            <label class="auto-save-toggle">
                <input type="checkbox" id="autoSaveToggle">
                <span>Auto-save</span>
            </label>
        </div>
        
        <!-- Status Bar -->
        <div id="statusBar" class="status-bar">
            <span id="connectionStatus">Disconnected</span>
            <span id="saveStatus"></span>
            <span id="zoomLevel">100%</span>
            <span id="coordinates">0, 0</span>
        </div>
    </div>
    
    <script src="public/canvas.js"></script>
    <script>
        if (window.InfiniteCanvas) {
        } else {
        // Canvas setup
        const canvas = document.getElementById('drawingCanvas');
        const previewCanvas = document.getElementById('previewCanvas');
        const ctx = canvas.getContext('2d');
        const previewCtx = previewCanvas.getContext('2d');

        // State
        let isDrawing = false;
        let isPanning = false;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let brushSize = 5;
        let brushOpacity = 1;
        let viewport = { x: 0, y: 0, scale: 1 };
        let lastPoint = null;
        let strokes = [];
        let currentStroke = null;
        let redoStack = [];

        // HUD elements (circular wheel center)
        const wheelToolLabel = document.getElementById('wheelToolLabel');
        const wheelSizeLabel = document.getElementById('wheelSizeLabel');
        const wheelOpacityLabel = document.getElementById('wheelOpacityLabel');
        const wheelColorDot = document.getElementById('wheelColorDot');

        // Setup canvas
        function resizeCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            canvas.width = width;
            canvas.height = height;
            previewCanvas.width = width;
            previewCanvas.height = height;
            
            redraw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Drawing functions
        function startDrawing(e) {
            const point = getPoint(e);
            
            // Alt+click: color picker (eyedropper) regardless of current tool
            if (e.altKey) {
                pickColorAtPoint(point);
                return;
            }
            
            if (currentTool === 'pan') {
                isPanning = true;
                lastPoint = point;
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            isDrawing = true;
            currentStroke = {
                tool: currentTool,
                color: currentColor,
                size: brushSize,
                opacity: brushOpacity,
                points: [point]
            };
            
            // For pen/brush, draw on preview canvas while stroking.
            // For eraser, draw directly on the main canvas so erasing is visible live.
            const ctxTarget = currentTool === 'eraser' ? ctx : previewCtx;
            drawPoint(point, ctxTarget);
        }

        function draw(e) {
            const point = getPoint(e);
            document.getElementById('coordinates').textContent = `${Math.round(point.x)}, ${Math.round(point.y)}`;
            
            if (isPanning && lastPoint) {
                // Use raw coordinates for panning (not scaled)
                viewport.x += point.rawX - lastPoint.rawX;
                viewport.y += point.rawY - lastPoint.rawY;
                lastPoint = point;
                redraw();
                return;
            }
            
            if (!isDrawing || !currentStroke) return;

            // Add new point to the stroke
            currentStroke.points.push(point);

            if (currentTool === 'eraser') {
                // Draw directly on the main canvas for live erasing
                const lastStrokePoint = currentStroke.points[currentStroke.points.length - 2];
                if (lastStrokePoint) {
                    drawLine(lastStrokePoint, point, ctx);
                }
            } else {
                // For pen/brush, clear preview and redraw the full stroke with pressure
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                drawStroke(currentStroke, previewCtx);
            }
            
            document.getElementById('saveStatus').textContent = `Drawing... (${currentStroke.points.length} points)`;
        }

        function stopDrawing() {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'crosshair';
                return;
            }
            
            if (!isDrawing || !currentStroke) return;
            
            isDrawing = false;
            strokes.push(currentStroke);
            redoStack = [];
            
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            redraw();
            
            currentStroke = null;
            document.getElementById('saveStatus').textContent = `${strokes.length} strokes`;
        }

        function getPoint(e) {
            const rect = canvas.getBoundingClientRect();
            // Check if it's a touch event
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Use raw hardware pressure when available (0.0 - 1.0 float)
            let rawPressure = 0;
            if (typeof e.pressure === 'number') {
                rawPressure = e.pressure;
            }

            // Effective pressure for stroke width (keep tiny minimum so strokes are visible)
            let pressure = rawPressure;
            if (pressure === 0 && (e.buttons || (e.touches && e.touches.length))) {
                pressure = 0.05;
            }
            
            return {
                x: (clientX - rect.left - viewport.x) / viewport.scale,
                y: (clientY - rect.top - viewport.y) / viewport.scale,
                pressure: pressure,
                rawPressure: rawPressure,
                rawX: clientX - rect.left,  // For panning
                rawY: clientY - rect.top    // For panning
            };
        }

        // Color picker: sample canvas pixel color at a given point and apply it
        function pickColorAtPoint(point) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor(point.rawX * scaleX);
            const y = Math.floor(point.rawY * scaleY);

            try {
                const data = ctx.getImageData(x, y, 1, 1).data;
                const color = `rgb(${data[0]}, ${data[1]}, ${data[2]})`;
                setStrokeColor(color);
            } catch (err) {
                // Ignore errors from getImageData outside bounds
            }
        }

        function drawPoint(point, context) {
            context.save();
            context.translate(viewport.x, viewport.y);
            context.scale(viewport.scale, viewport.scale);
            context.globalAlpha = brushOpacity;
            context.fillStyle = currentTool === 'eraser' ? '#FFFFFF' : currentColor;
            
            // Map pressure 0..1 to a width range [minWidth, brushSize]
            const minWidth = 1;
            const maxWidth = Math.max(minWidth, brushSize);
            const width = minWidth + (maxWidth - minWidth) * point.pressure;
            const radius = width / 2;

            context.beginPath();
            context.arc(point.x, point.y, radius, 0, Math.PI * 2);
            context.fill();
            context.restore();
        }

        function drawLine(from, to, context) {
            context.save();
            context.translate(viewport.x, viewport.y);
            context.scale(viewport.scale, viewport.scale);
            context.globalAlpha = brushOpacity;
            context.strokeStyle = currentTool === 'eraser' ? '#FFFFFF' : currentColor;

            const avgPressure = (from.pressure + to.pressure) / 2;
            const minWidth = 1;
            const maxWidth = Math.max(minWidth, brushSize);
            const width = minWidth + (maxWidth - minWidth) * avgPressure;
            context.lineWidth = width;

            context.lineCap = 'round';
            context.lineJoin = 'round';
            
            if (currentTool === 'eraser') {
                context.globalCompositeOperation = 'destination-out';
            }
            
            context.beginPath();
            context.moveTo(from.x, from.y);
            context.lineTo(to.x, to.y);
            context.stroke();
            context.restore();
        }

        function drawStroke(stroke, context) {
            if (stroke.points.length === 0) return;
            
            context.save();
            context.translate(viewport.x, viewport.y);
            context.scale(viewport.scale, viewport.scale);
            context.globalAlpha = stroke.opacity;
            
            if (stroke.tool === 'eraser') {
                context.globalCompositeOperation = 'destination-out';
            }
            
            // Draw each segment with its own pressure
            for (let i = 0; i < stroke.points.length; i++) {
                if (i === 0) {
                    // Draw first point as a circle
                    const point = stroke.points[i];
                    context.fillStyle = stroke.tool === 'eraser' ? '#FFFFFF' : stroke.color;
                    context.beginPath();
                    context.arc(point.x, point.y, stroke.size * point.pressure / 2, 0, Math.PI * 2);
                    context.fill();
                } else {
                    // Draw line segment with interpolated pressure
                    const prevPoint = stroke.points[i - 1];
                    const point = stroke.points[i];
                    
                    context.strokeStyle = stroke.tool === 'eraser' ? '#FFFFFF' : stroke.color;
                    context.lineWidth = stroke.size * ((prevPoint.pressure + point.pressure) / 2);
                    context.lineCap = 'round';
                    context.lineJoin = 'round';
                    
                    context.beginPath();
                    context.moveTo(prevPoint.x, prevPoint.y);
                    context.lineTo(point.x, point.y);
                    context.stroke();
                }
            }
            
            context.restore();
        }

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            strokes.forEach(stroke => drawStroke(stroke, ctx));
        }

        // Event listeners
        canvas.addEventListener('pointerdown', startDrawing);
        canvas.addEventListener('pointermove', draw);
        canvas.addEventListener('pointerup', stopDrawing);
        canvas.addEventListener('pointercancel', stopDrawing);
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Touch support
        canvas.addEventListener('touchstart', e => { e.preventDefault(); startDrawing(e); });
        canvas.addEventListener('touchmove', e => { e.preventDefault(); draw(e); });
        canvas.addEventListener('touchend', e => { e.preventDefault(); stopDrawing(); });

        // Wheel zoom
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            
            const point = getPoint(e);
            const scaleDelta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(10, viewport.scale * scaleDelta));
            
            // Zoom towards mouse position
            const scaleChange = newScale / viewport.scale;
            viewport.x = point.rawX - (point.rawX - viewport.x) * scaleChange;
            viewport.y = point.rawY - (point.rawY - viewport.y) * scaleChange;
            viewport.scale = newScale;
            
            document.getElementById('zoomLevel').textContent = Math.round(viewport.scale * 100) + '%';
            redraw();
        });

        // Core tool selection API (UI can call these to change behavior)
        function usePenTool() {
            selectToolInternal('pen');
        }

        function useBrushTool() {
            selectToolInternal('brush');
        }

        function useEraserTool() {
            selectToolInternal('eraser');
        }

        function usePanTool() {
            selectToolInternal('pan');
        }

        // Internal helper used by all tool selectors
        function selectToolInternal(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                const label = btn.textContent.trim().toLowerCase();
                btn.classList.toggle('active', label === tool);
            });
            canvas.style.cursor = tool === 'pan' ? 'grab' : 'crosshair';

            if (wheelToolLabel) {
                wheelToolLabel.textContent = tool.charAt(0).toUpperCase() + tool.slice(1);
            }
        }

        // Existing UI hook for inline onclicks
        function selectTool(tool) {
            selectToolInternal(tool);
        }

        function updateWheelColorSelection(color) {
            if (wheelColorDot) {
                wheelColorDot.style.background = color;
            }

            document.querySelectorAll('.wheel-color').forEach(chip => {
                chip.classList.toggle('active', chip.dataset.color === color);
            });

            document.querySelectorAll('.color-preset').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === color);
            });
        }

        // Core color API
        function setStrokeColor(color) {
            currentColor = color;
            document.getElementById('colorPicker').value = color;
            updateWheelColorSelection(color);
        }

        // Keep old name as a thin wrapper for existing UI
        function setColor(color) {
            setStrokeColor(color);
        }

        function setColorFromWheel(el) {
            const color = el.dataset.color;
            setColor(color);
        }

        // Core size API
        function setStrokeSize(size) {
            brushSize = parseInt(size);
            document.getElementById('sizeValue').textContent = size;
            if (wheelSizeLabel) {
                wheelSizeLabel.textContent = `Size ${size}`;
            }
        }

        function updateSize(size) {
            setStrokeSize(size);
        }

        // Core opacity API
        function setStrokeOpacity(opacityPercent) {
            brushOpacity = parseInt(opacityPercent) / 100;
            document.getElementById('opacityValue').textContent = opacityPercent;
            if (wheelOpacityLabel) {
                wheelOpacityLabel.textContent = `${opacityPercent}%`;
            }
        }

        function updateOpacity(opacity) {
            setStrokeOpacity(opacity);
        }

        function clearCanvas() {
            if (confirm('Clear the entire canvas?')) {
                strokes = [];
                redoStack = [];
                redraw();
                document.getElementById('saveStatus').textContent = 'Canvas cleared';
            }
        }

        function undo() {
            if (strokes.length > 0) {
                redoStack.push(strokes.pop());
                redraw();
                document.getElementById('saveStatus').textContent = 'Undone';
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                strokes.push(redoStack.pop());
                redraw();
                document.getElementById('saveStatus').textContent = 'Redone';
            }
        }

        function saveCanvas() {
            const link = document.createElement('a');
            link.download = 'canvas-' + Date.now() + '.png';
            link.href = canvas.toDataURL();
            link.click();
            document.getElementById('saveStatus').textContent = 'Image saved!';
        }

        // Color picker
        document.getElementById('colorPicker').addEventListener('change', e => {
            currentColor = e.target.value;
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) redo();
                        else undo();
                        break;
                    case 's':
                        e.preventDefault();
                        saveCanvas();
                        break;
                }
            }
        });

        // Initialize wheel HUD to match defaults
        if (wheelToolLabel) {
            wheelToolLabel.textContent = 'Pen';
        }
        if (wheelSizeLabel) {
            wheelSizeLabel.textContent = `Size ${brushSize}`;
        }
        if (wheelOpacityLabel) {
            wheelOpacityLabel.textContent = '100%';
        }
        updateWheelColorSelection(currentColor);

        // Initial message
        document.getElementById('saveStatus').textContent = 'Ready to draw! Use pen/stylus for pressure sensitivity';
        }
    </script>
    <script>
        (function() {
            if (window.location.protocol === 'file:') {
                if (window.InfiniteCanvas && window.InfiniteCanvas.prototype) {
                    InfiniteCanvas.prototype.setupWebSocket = function() {
                        var status = document.getElementById('connectionStatus');
                        if (status) {
                            status.textContent = 'Offline (standalone)';
                            status.className = 'disconnected';
                        }
                    };
                    InfiniteCanvas.prototype.saveToServer = async function() {
                        var saveStatus = document.getElementById('saveStatus');
                        if (saveStatus) {
                            saveStatus.textContent = 'Local-only: no server';
                            setTimeout(function() { saveStatus.textContent = ''; }, 2000);
                        }
                    };
                    InfiniteCanvas.prototype.loadBoard = async function() {
                    };
                    InfiniteCanvas.prototype.toggleAutoSave = function() {
                    };
                }
            }
        })();
    </script>
</body>
</html>
